#!/usr/bin/env python

# pylint: disable=E1101,C0114,C0116
import re
import os
import sys
import hashlib
import datetime
import json

try:
    from yaml import CLoader as Loader, CDumper as Dumper, safe_load
except ImportError:
    from yaml import Loader, Dumper, safe_load
from pprint import pprint

import sh
import click


def parse_bonuses(data):
    options = None
    descriptor = None
    texture = None
    orig = data

    def _split_by(char):
        parts = data.split(char)
        if len(parts) == 1:
            return parts[0], []
        assert len(parts) == 2, parts
        return parts[0], parts[1].split(",")

    data, options = _split_by("+")
    data, descriptor = _split_by("#")
    data, texture = _split_by("%")
    if len(texture) > 0:
        assert len(texture) == 1, orig
        texture = texture[0]
    return data, texture, descriptor, options


def get_piece(file, tags):
    if len(file["path"]) == 0:
        return None, file
    file["piece"] = file["path"].pop(0)
    piece, texture, descriptor, options = parse_bonuses(file["piece"])
    if texture:
        file["floor_texture"] = texture
    file["piece"] = piece
    if len(descriptor) > 0:
        file["piece_descriptor"] = descriptor
    if len(options) > 0:
        file["piece_options"] = options
    return file, None


def get_function(file, tags):
    function = file["path"].pop(0)
    function, texture, descriptor, options = parse_bonuses(function)
    assert not texture, file
    file["function"] = function
    if len(descriptor) > 0:
        file["function_descriptor"] = descriptor
    if len(options) > 0:
        file["function_options"] = options
    return file


def get_scheme(file, tags):
    file["scheme"] = file["path"].pop(0)
    return file


def get_texture(file, tags):
    tag = ("texture", file["path"].pop(0))
    tags.add(tag)
    return file


def parse_texture(texture, tags):
    parts = texture.split("%")
    main = parts.pop(0)
    for m in main.split(","):
        if m.find("+") > 0:
            raise Exception(f"Texture {m} contains +")
        tags.add(("texture", m))
    if len(parts) == 0:
        return
    subtex = parts.pop(0)
    for o in subtex.split(","):
        if o.find("+") > 0:
            raise Exception(f"Subtexture {o} contains +")
        tags.add(("texture", "floor", o))


def parse_form(form, tags):
    texture, form = form.split("#")
    parse_texture(texture, tags)


def parse_size(size, tags):
    sizes = {
        "A": [("size", "width", 2), ("size", "openlock", "A"), ("shape", "wall")],
        "A+S": [
            ("size", "width", 2.5),
            ("size", "depth", 1),
            ("size", "openlock", "A+S"),
            ("shape", "square"),
            ("shape", "wall"),
        ],
        "AS": [("size", "width", 2), ("size", "openlock", "AS"), ("shape", "wall")],
        "BA": [("size", "width", 1.5), ("size", "openlock", "BA"), ("shape", "wall")],
        "BA+mirror": [
            ("size", "width", 1.5),
            ("size", "openlock", "BA"),
            ("shape", "wall"),
            ("shape", "option", "mirror"),
        ],
        "D": [("size", "width", 3), ("size", "openlock", "D"), ("shape", "wall")],
        "IA": [("size", "width", 3), ("size", "openlock", "IA"), ("shape", "wall")],
        "Q": [("size", "width", 4), ("size", "openlock", "Q"), ("shape", "wall")],
        "G": [
            ("size", "radius", 2),
            ("angle", 90),
            ("size", "openlock", "G"),
            ("shape", "wall"),
        ],
        "GA": [
            ("size", "radius", 2),
            ("angle", 45),
            ("size", "openlock", "GA"),
            ("shape", "wall"),
        ],
        "X": [
            ("size", "radius", 4),
            ("angle", 90),
            ("size", "openlock", "X"),
            ("shape", "wall"),
        ],
        "XA": [
            ("size", "radius", 4),
            ("angle", 45),
            ("size", "openlock", "XA"),
            ("shape", "wall"),
        ],
        "col+O": [
            ("size", "shape", "O"),
            ("size", "openlock", "O"),
            ("shape", "column"),
        ],
        "col+I": [
            ("size", "shape", "I"),
            ("size", "openlock", "I"),
            ("shape", "column"),
        ],
        "col+L": [
            ("size", "shape", "L"),
            ("size", "openlock", "L"),
            ("shape", "column"),
        ],
        "col+T": [
            ("size", "shape", "T"),
            ("size", "openlock", "T"),
            ("shape", "column"),
        ],
        "col+X": [
            ("size", "shape", "X"),
            ("size", "openlock", "X"),
            ("shape", "column"),
        ],
        "IO": [
            ("size", "width", 1),
            ("size", "depth", 1),
            ("size", "openlock", "IO"),
            ("shape", "square"),
        ],
        "II": [
            ("size", "width", 1),
            ("size", "depth", 1),
            ("size", "openlock", "II"),
            ("shape", "square"),
        ],
        "IL": [
            ("size", "width", 1),
            ("size", "depth", 1),
            ("size", "openlock", "IL"),
            ("shape", "square"),
        ],
        "IT": [
            ("size", "width", 1),
            ("size", "depth", 1),
            ("size", "openlock", "IT"),
            ("shape", "square"),
        ],
        "IX": [
            ("size", "width", 1),
            ("size", "depth", 1),
            ("size", "openlock", "IX"),
            ("shape", "square"),
        ],
        "I": [
            ("size", "width", 1),
            ("size", "depth", 1),
            ("size", "openlock", "I"),
            ("shape", "square"),
        ],
        "S": [
            ("size", "width", 2),
            ("size", "depth", 1),
            ("size", "openlock", "S"),
            ("shape", "square"),
        ],
        "S+wall": [
            ("size", "width", 2),
            ("size", "depth", 1),
            ("size", "openlock", "S"),
            ("shape", "square"),
            ("shape", "wall"),
        ],
        "SA": [
            ("size", "width", 3),
            ("size", "depth", 1),
            ("size", "openlock", "SA"),
            ("shape", "square"),
        ],
        "SB": [
            ("size", "width", 4),
            ("size", "depth", 1),
            ("size", "openlock", "SB"),
            ("shape", "square"),
        ],
        "E": [
            ("size", "width", 2),
            ("size", "depth", 2),
            ("size", "openlock", "E"),
            ("shape", "square"),
        ],
        "EA": [
            ("size", "width", 3),
            ("size", "depth", 3),
            ("size", "openlock", "EA"),
            ("shape", "square"),
        ],
        "R": [
            ("size", "width", 4),
            ("size", "depth", 2),
            ("size", "openlock", "R"),
            ("shape", "square"),
        ],
        "U": [
            ("size", "width", 4),
            ("size", "depth", 4),
            ("size", "openlock", "U"),
            ("shape", "square"),
        ],
        "F": [
            ("size", "radius", 2),
            ("size", "angle", 90),
            ("size", "openlock", "F"),
            ("shape", "curved"),
        ],
        "V": [
            ("size", "radius", 4),
            ("size", "angle", 90),
            ("size", "openlock", "V"),
            ("shape", "curved"),
        ],
        "VxE": [
            ("size", "radius", 4),
            ("size", "angle", 90),
            ("size", "openlock", "VxE"),
            ("shape", "curved"),
            ("shape", "option", "notch"),
        ],
        "AxG": [
            ("size", "width", 2),
            ("size", "openlock", "AxG"),
            ("shape", "wall"),
            ("shape", "option", "curved_interface"),
        ],
        "BAxG": [
            ("size", "width", 1.5),
            ("size", "openlock", "BAxG"),
            ("shape", "wall"),
            ("shape", "option", "curved_interface"),
        ],
        "QxG": [
            ("size", "width", 4),
            ("size", "depth", 4),
            ("size", "openlock", "QxG"),
            ("shape", "square"),
            ("shape", "option", "curved_interface"),
        ],
        "x": [("shape", "corner pillar")],
        "1x": [("size", "width", 1), ("size", "openlock", "IA"), ("shape", "wall")],
        "2x": [("size", "width", 2), ("size", "openlock", "A"), ("shape", "wall")],
        "3x": [("size", "width", 3), ("size", "openlock", "D"), ("shape", "wall")],
        "4x": [("size", "width", 4), ("size", "openlock", "Q"), ("shape", "wall")],
        "1x1": [("size", "width", 1), ("size", "depth", 1)],
        "1x2": [("size", "width", 1), ("size", "depth", 2)],
        "1x3": [("size", "width", 1), ("size", "depth", 3)],
        "1x4": [("size", "width", 1), ("size", "depth", 4)],
        "2x1": [("size", "width", 2), ("size", "depth", 1)],
        "2x2": [("size", "width", 2), ("size", "depth", 2)],
        "2x3": [("size", "width", 2), ("size", "depth", 3)],
        "2x4": [("size", "width", 2), ("size", "depth", 4)],
        "3x1": [("size", "width", 3), ("size", "depth", 1)],
        "3x2": [("size", "width", 3), ("size", "depth", 2)],
        "3x3": [("size", "width", 3), ("size", "depth", 3)],
        "3x4": [("size", "width", 3), ("size", "depth", 4)],
        "4x1": [("size", "width", 4), ("size", "depth", 1)],
        "4x2": [("size", "width", 4), ("size", "depth", 2)],
        "4x3": [("size", "width", 4), ("size", "depth", 3)],
        "4x4": [("size", "width", 4), ("size", "depth", 4)],
        "4x6": [("size", "width", 4), ("size", "depth", 6)],
        "4x4+a": [
            ("size", "width", 4),
            ("size", "depth", 4),
            ("segment", "a"),
            ("shape", "curved"),
        ],
        "4x4+b": [
            ("size", "width", 4),
            ("size", "depth", 4),
            ("segment", "b"),
            ("shape", "curved"),
        ],
        "4x4+c": [
            ("size", "width", 4),
            ("size", "depth", 4),
            ("segment", "c"),
            ("shape", "curved"),
        ],
        "6x2": [("size", "width", 6), ("size", "depth", 2)],
        "6x4": [("size", "width", 6), ("size", "depth", 4)],
        "6x6": [("size", "width", 6), ("size", "depth", 6)],
        "6x6+a": [
            ("size", "width", 6),
            ("size", "depth", 6),
            ("segment", "a"),
            ("shape", "curved"),
        ],
        "6x6+b": [
            ("size", "width", 6),
            ("size", "depth", 6),
            ("segment", "b"),
            ("shape", "curved"),
        ],
        "6x6+c": [
            ("size", "width", 6),
            ("size", "depth", 6),
            ("segment", "c"),
            ("shape", "curved"),
        ],
        "6x6+ac": [
            ("size", "width", 6),
            ("size", "depth", 6),
            ("segment", "ac"),
            ("shape", "curved"),
        ],
        "8x2": [("size", "width", 8), ("size", "depth", 2)],
        "8x8": [("size", "width", 8), ("size", "depth", 8)],
        "8x8+a": [
            ("size", "width", 8),
            ("size", "depth", 8),
            ("segment", "a"),
            ("shape", "curved"),
        ],
        "8x8+b": [
            ("size", "width", 8),
            ("size", "depth", 8),
            ("segment", "b"),
            ("shape", "curved"),
        ],
        "8x8+c": [
            ("size", "width", 8),
            ("size", "depth", 8),
            ("segment", "c"),
            ("shape", "curved"),
        ],
        "8x8+ac": [
            ("size", "width", 8),
            ("size", "depth", 8),
            ("segment", "ac"),
            ("shape", "curved"),
        ],
        "8x8+ax": [
            ("size", "width", 8),
            ("size", "depth", 8),
            ("segment", "ax"),
            ("shape", "curved"),
        ],
        "8x8+cx": [
            ("size", "width", 8),
            ("size", "depth", 8),
            ("segment", "cx"),
            ("shape", "curved"),
        ],
        "8x2": [("size", "width", 8), ("size", "depth", 2)],
        "2r22.5°": [
            ("size", "radius", 2),
            ("size", "angle", 22.5),
            ("shape", "curved"),
        ],
        "2r45°": [("size", "radius", 2), ("size", "angle", 45), ("shape", "curved")],
        "2r90°": [("size", "radius", 2), ("size", "angle", 90), ("shape", "curved")],
        "4r22.5°": [
            ("size", "radius", 4),
            ("size", "angle", 22.5),
            ("shape", "curved"),
        ],
        "4r45°": [("size", "radius", 4), ("size", "angle", 45), ("shape", "curved")],
        "4r90°": [("size", "radius", 4), ("size", "angle", 90), ("shape", "curved")],
        "6r11.25°": [
            ("size", "radius", 6),
            ("size", "angle", 11.25),
            ("shape", "curved"),
        ],
        "6r22.5°": [
            ("size", "radius", 6),
            ("size", "angle", 22.5),
            ("shape", "curved"),
        ],
        "6r45°": [("size", "radius", 6), ("size", "angle", 45), ("shape", "curved")],
        "2r": [("size", "radius", 2), ("size", "angle", 90), ("shape", "curved")],
        "4r": [("size", "radius", 4), ("size", "angle", 90), ("shape", "curved")],
        "6r": [("size", "radius", 6), ("size", "angle", 90), ("shape", "curved")],
        "3x3+2r": [
            ("size", "width", 3),
            ("size", "depth", 3),
            ("size", "radius", 2),
            ("shape", "curved"),
        ],
        "5x5+4r": [
            ("size", "width", 5),
            ("size", "depth", 5),
            ("size", "radius", 4),
            ("shape", "curved"),
        ],
        "7x7+6r": [
            ("size", "width", 7),
            ("size", "depth", 7),
            ("size", "radius", 6),
            ("shape", "curved"),
        ],
    }
    for tag in sizes[size]:
        tags.add(tag)


def parse_connection(connection, tags):
    def _add_connections(connections):
        for connection in connections:
            if "+" in connection:
                options = connection.split("+")
                connection = options.pop(0)
                for option in options:
                    tags.add(("connection", connection, option))
            tags.add(("connection", connection))

    parts = connection.split(",")
    _add_connections(parts)


def parse_filename(file, tags):
    try:
        parts = file["file"].split(".")
        extension = parts.pop()
        form = parts.pop(0)
        size = parts.pop(0)
        connection = None
        if len(parts) > 0:
            connection = parts.pop()
        if len(parts) == 1:
            if re.match(r"^\d", parts[0]):
                size = f"{size}.{parts.pop(0)}"
        assert connection
        assert len(parts) == 0, parts
        parse_form(form, tags)
        parse_size(size, tags)
        parse_connection(connection, tags)
    except Exception as e:
        sys.stderr.write(f"Can't parse: {file['full_name']}\n")
        sys.stderr.write(f"{e}\n")
        raise e


def parse_files(path, files, md5):
    def _get_metadata_file(path):
        metadata_file = os.path.join(path, "metadata.yaml")
        if os.path.exists(metadata_file):
            try:
                with open(metadata_file, "r") as f:
                    return safe_load(f)
            except Exception as e:
                sys.stderr.write(f"Error reading metadata file: {e}\n")
        return None

    def _get_metadata(path, fn):
        data = _get_metadata_file(path)
        if data:
            if fn in data:
                return data[fn]
        return None

    newfiles = []
    donefiles = []
    for file in files:
        full_file = os.path.join(path, file)
        local_path = os.path.dirname(full_file)
        fn = os.path.basename(full_file)
        f = {}
        t = set()
        o = {"type": "model", "file_metadata": f, "tags": t}
        parts = file.split("/")
        f["full_name"] = file
        f["file"] = fn
        f["path"] = parts
        metadata = _get_metadata(local_path, fn)
        if metadata and metadata.get("ignore", False):
            continue
        # Calculate MD5 hash of the file
        if md5:
            with open(full_file, "rb") as fh:
                md5hash = hashlib.md5(fh.read()).hexdigest()
                f["md5"] = md5hash
        stat = os.stat(full_file)
        f["size"] = stat.st_size
        f["changed"] = datetime.datetime.fromtimestamp(stat.st_ctime).isoformat()
        f["modified"] = datetime.datetime.fromtimestamp(stat.st_mtime).isoformat()

        parse_filename(f, t)
        # f = get_texture(f, t)
        # f = get_scheme(f, t)
        # f = get_function(f, t)
        # f, d = get_piece(f, t)
        # if f and f['path'] == []:
        #    del f["path"]
        # elif f:
        #    f['connections'] = f["path"]
        del f["path"]
        # if d:
        #    donefiles.append(d)
        #    continue
        newfiles.append(o)
    return newfiles, donefiles


def clean_files(path, files):
    newfiles = []
    for file in files:
        parts = file.split(path)
        if len(parts) == 1:
            continue
        assert len(parts) == 2, parts
        newfiles.append(parts[1])
    return newfiles


def find_files(path, subset):
    files = sh.find(os.path.join(path, subset), "-type", "f", "-name", "*.stl")
    return files.split("\n")


def print_files(files):
    def set_handler(obj):
        if isinstance(obj, (set, tuple)):
            return list(obj)
        raise TypeError(f"Object of type {type(obj)} is not JSON serializable")

    print(json.dumps(files, default=set_handler, indent=4))


@click.command()
@click.option(
    "--path", default="/home/devon/Dropbox/projects/Hardware/objects/OpenForge/"
)
@click.option("--subset", default="tiles/dungeon_stone")
@click.option("--md5/--no-md5", default=True, help="Calculate MD5 hash for files")
def main(path, subset, md5):
    files = find_files(path, subset)
    files = clean_files(path, files)
    files, donefiles = parse_files(path, files, md5)
    print_files(files)


if __name__ == "__main__":
    sys.exit(main())
